<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-03-13T11:04:32-03:00</updated><id>http://localhost:4000/</id><title type="html">Wind and Water</title><subtitle>The fascination of what's difficult...</subtitle><author><name>Douglas Lovell</name></author><entry><title type="html">Merging migrations</title><link href="http://localhost:4000/git/rails/database/2018/03/09/merging-structure.html" rel="alternate" type="text/html" title="Merging migrations" /><published>2018-03-09T00:00:00-03:00</published><updated>2018-03-09T00:00:00-03:00</updated><id>http://localhost:4000/git/rails/database/2018/03/09/merging-structure</id><content type="html" xml:base="http://localhost:4000/git/rails/database/2018/03/09/merging-structure.html">&lt;p&gt;In Rails, the file &lt;code class=&quot;highlighter-rouge&quot;&gt;db/structure.sql&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;db/schema.rb&lt;/code&gt; (depending)
captures a snapshot of the state of the development database after a
migration, when you run the &lt;code class=&quot;highlighter-rouge&quot;&gt;db:migrate&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;db:schema:dump&lt;/code&gt; tasks.&lt;/p&gt;

&lt;p&gt;What do you do when you have migrations in two different branches
of your development tree? Do you get a merge conflict? How do you resolve it?
What if you don’t get a merge conflict?&lt;/p&gt;

&lt;p&gt;I’ll use the term “schema” now to refer to the file
(&lt;code class=&quot;highlighter-rouge&quot;&gt;db/structure.sql&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;db/schema.rb&lt;/code&gt;).
It is the file that captures the structure of the database.
Because the schema is generated by a program, not hand written, the best
effort of &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; to try to merge two changes to it will often produce a
result different than what you will get from running the &lt;code class=&quot;highlighter-rouge&quot;&gt;db:schema:dump&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Why is that important?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It might have duplications or content out of sequence.&lt;/li&gt;
  &lt;li&gt;The next migration will produce a schema with differences
unrelated to the migration.&lt;/li&gt;
  &lt;li&gt;The schema is the only source of truth about the database structure.
It deserves extra care, to keep it aligned with what the framework
and tooling expect and produce.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here’s a process that allows the tooling to keep the schema in order,
combining independent migrations without errors induced by merging.&lt;/p&gt;

&lt;p&gt;First, do not allow git to merge the file. Set-up git to always treat
independent changes to the schema as a conflict. You do this by placing
a &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitattributes&lt;/code&gt; file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;db&lt;/code&gt; directory with content,&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;schema.rb merge binary
structure.sql merge binary
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(Or add those lines to the existing &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitattributes&lt;/code&gt; file if there is one.)
The reference for doing that is deep down in the documentation of
&lt;a href=&quot;https://www.git-scm.com/docs/gitattributes&quot;&gt;gitattributes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Second, when you do get a conflict, resolve it as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Checkout &lt;strong&gt;their&lt;/strong&gt; version, &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout --theirs db/structure.sql&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Accept that change, &lt;code class=&quot;highlighter-rouge&quot;&gt;git add db/structure.sql&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After you have finished the merge and committed the changes (&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Reset the development database such that it matches the structure of
&lt;strong&gt;their&lt;/strong&gt; version, e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;rails db:reset&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Rerun the migrations from your branch, &lt;code class=&quot;highlighter-rouge&quot;&gt;rails db:migrate&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Accept the newly generated schema, e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;git add db/structure.sql&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Make that new commit, &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this way, your database schema will always be wholly in agreement with
the text wanted by the framework, because it is always and only ever generated
by the framework.&lt;/p&gt;</content><author><name>Douglas Lovell</name></author><summary type="html">In Rails, the file db/structure.sql or db/schema.rb (depending) captures a snapshot of the state of the development database after a migration, when you run the db:migrate or db:schema:dump tasks.</summary></entry><entry><title type="html">Git merge v. rebase</title><link href="http://localhost:4000/git/teams/kiss/religion/2018/03/08/rebase-v-merge.html" rel="alternate" type="text/html" title="Git merge v. rebase" /><published>2018-03-08T00:00:00-03:00</published><updated>2018-03-08T00:00:00-03:00</updated><id>http://localhost:4000/git/teams/kiss/religion/2018/03/08/rebase-v-merge</id><content type="html" xml:base="http://localhost:4000/git/teams/kiss/religion/2018/03/08/rebase-v-merge.html">&lt;p&gt;I’ve been looking into the git merge v. rebase endless theological debate.
It comes up over and over. But I’ve only ever gotten into trouble
trying to rebase. Not getting all wrapped up over how my
commit history looks and just merging has given me fewer issues.&lt;/p&gt;

&lt;p&gt;I’m seeing a camp that recommends rebasing your local feature branch when
master gets ahead of it, but merging it when you bring it back into master.
Another person says, yeah, do that, but if your rebase has conflicts,
give it up and merge instead.&lt;/p&gt;

&lt;p&gt;I’ll paste some links now. …&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/11219380/608359&quot;&gt;SO: Conflict resolution during rebase&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/git/articles/git-team-workflows-merge-or-rebase&quot;&gt;Atlassian article&lt;/a&gt;
has pros and cons and what Atlassian does.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/a/36587353/608359&quot;&gt;SO: When to rebase&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.atlassian.com/git/tutorials/merging-vs-rebasing&quot;&gt;Atlassian tutorial&lt;/a&gt;
Contains “The Golden Rule of Rebasing” and after two thousand words says,
“that’s all you really need to know to start”.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The gist I’m taking away is that it’s okay (but entirely optional) to rebase
your feature branch occasionally before finally &lt;strong&gt;merging&lt;/strong&gt; it back to master.&lt;/p&gt;

&lt;p&gt;All of the caveats and warnings I’m seeing in these threads are about rebase.
That tells me something. My friend, KISS says, “Just merge and stop fussing.”&lt;/p&gt;</content><author><name>Douglas Lovell</name></author><summary type="html">I’ve been looking into the git merge v. rebase endless theological debate. It comes up over and over. But I’ve only ever gotten into trouble trying to rebase. Not getting all wrapped up over how my commit history looks and just merging has given me fewer issues.</summary></entry><entry><title type="html">RSpec have HTTP status upgrade</title><link href="http://localhost:4000/rspec/rails/upgrading/2018/02/23/have-http-status.html" rel="alternate" type="text/html" title="RSpec have HTTP status upgrade" /><published>2018-02-23T00:00:00-03:00</published><updated>2018-02-23T00:00:00-03:00</updated><id>http://localhost:4000/rspec/rails/upgrading/2018/02/23/have-http-status</id><content type="html" xml:base="http://localhost:4000/rspec/rails/upgrading/2018/02/23/have-http-status.html">&lt;p&gt;When upgrading a project to the Rails 5.2 pre-release we started to see
some deprecation warnings in our RSpec runs.
The warnings were as follows, and occurred wherever
&lt;code class=&quot;highlighter-rouge&quot;&gt;have_http_status(:success)&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;have_success_status&lt;/code&gt; and the like
were used in tests.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.DEPRECATION WARNING: The success? predicate is deprecated and will be removed
in Rails 6.0. Please use successful? as provided by Rack::Response::Helpers.
(called from matches? at rspec/rails/matchers/have_http_status.rb:263)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This was annoying because many controller tests use
the &lt;code class=&quot;highlighter-rouge&quot;&gt;have_success_status&lt;/code&gt; matcher.&lt;/p&gt;

&lt;h2 id=&quot;what-changed&quot;&gt;What changed&lt;/h2&gt;
&lt;p&gt;Rails, with &lt;a href=&quot;https://github.com/rails/rails/pull/30104/files&quot;&gt;this commit&lt;/a&gt;
decided, in very reasonable fashion, to standardize the response status
checking methods in ActionDispatch::TestResponse.&lt;/p&gt;

&lt;p&gt;The team simply deprecated the &lt;code class=&quot;highlighter-rouge&quot;&gt;success?&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;missing?&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;error?&lt;/code&gt; methods
with the suggestion to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;successful?&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;not_found?&lt;/code&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;server_error?&lt;/code&gt; methods pre-existing in
&lt;a href=&quot;https://github.com/rack/rack/blob/b37356ee881c0de4266165dacb8af4efaebaf4ec/lib/rack/response.rb#L110&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Rack::Response::Helpers&lt;/code&gt;&lt;/a&gt;.
(&lt;code class=&quot;highlighter-rouge&quot;&gt;ActionDispatch::TestResponse&lt;/code&gt; inherits from &lt;code class=&quot;highlighter-rouge&quot;&gt;ActionDispatch::Response&lt;/code&gt; which
includes &lt;code class=&quot;highlighter-rouge&quot;&gt;Rack::Response::Helpers&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;rspec-rails&lt;/code&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;have_http_status&lt;/code&gt; matcher called these methods
in a meta-sense, by mapping the &lt;code class=&quot;highlighter-rouge&quot;&gt;:success&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;:missing&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;:error&lt;/code&gt;
symbols to corresponding methods invoked on the response.&lt;/p&gt;

&lt;h2 id=&quot;how-to-repair&quot;&gt;How to repair?&lt;/h2&gt;
&lt;p&gt;One way to repair this would have been to support the replacement methods,
e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;successful?&lt;/code&gt; and require any extant tests using, for example,
&lt;code class=&quot;highlighter-rouge&quot;&gt;have_http_status(:success)&lt;/code&gt; to make the change to
&lt;code class=&quot;highlighter-rouge&quot;&gt;have_http_status(:successful)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This would possibly be defensible as a “follow closely as a thin wrapper on
Rails” strategy. Unfortunately, it would break a mountain of tests!&lt;/p&gt;

&lt;p&gt;However the &lt;code class=&quot;highlighter-rouge&quot;&gt;successful?&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;server_error?&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;not_found?&lt;/code&gt; methods have
been available to &lt;code class=&quot;highlighter-rouge&quot;&gt;ActionDispatch::TestResponse&lt;/code&gt; via
&lt;code class=&quot;highlighter-rouge&quot;&gt;Rack::Response::Helpers&lt;/code&gt; for many many years.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://github.com/rspec/rspec-rails/pull/1951&quot;&gt;method provided&lt;/a&gt;
introduces the new status codes, &lt;code class=&quot;highlighter-rouge&quot;&gt;:successful&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;:not_found&lt;/code&gt;,
and &lt;code class=&quot;highlighter-rouge&quot;&gt;:server_error&lt;/code&gt; while maintaining support for the Rails deprecated ones.
It does so by mapping, for example, &lt;code class=&quot;highlighter-rouge&quot;&gt;:success&lt;/code&gt; to the &lt;code class=&quot;highlighter-rouge&quot;&gt;successful?&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;Thus the world of &lt;code class=&quot;highlighter-rouge&quot;&gt;rspec-rails&lt;/code&gt; turns in accordance with the heavens,
that is, Rails.&lt;/p&gt;</content><author><name>Douglas Lovell</name></author><summary type="html">When upgrading a project to the Rails 5.2 pre-release we started to see some deprecation warnings in our RSpec runs. The warnings were as follows, and occurred wherever have_http_status(:success) or have_success_status and the like were used in tests.</summary></entry></feed>